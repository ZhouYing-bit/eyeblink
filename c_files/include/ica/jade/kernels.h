#ifndef JADE_KERNELS_H
#define JADE_KERNELS_H

#include "numtype.h"

/**
 * Name: jade_identity
 *
 * Description:
 * Initializes a matrix to the identity matrix.
 *
 * CUDA dimensions:
 * If d_M is an n x n matrix:
 * grid_size  = dim3( n )
 * block_size = dim3( n )
 *
 * Parameters:
 * @param d_M         the matrix to initialize
 * @param ld          the leading dimension of the given matrix
 */
void __global__ jade_identity( NUMTYPE *d_M, unsigned int ld );

/**
 * Name: jade_genCumulants
 *
 * Description:
 * Generates the cumulant matrices for a given set of observation vectors,
 * stored in the matrix 'X'. Each column of X should be a random variable, each
 * row of X should be an observation of those random variables.
 *
 * The resulting cumulant matrices are stored in the matrix 'Q'. If X is a
 * T x n matrix, the Q matrix must have space for n*n*n*(n+1)/2 floating point
 * elements. Each consecutive grouping of n*n elements in the Q matrix
 * represents a single cumulant matrix.
 *
 * CUDA dimensions:
 * if d_X is an T x n matrix:
 * grid_size  = dim3( n, n*n*(n+1)/2, 1 )
 * block_size = dim3( 256 )
 *
 * PRE:
 * The given 'X' matrix is assumed to be a set of whitened variables, i.e., each
 * variable is expected to be zero-mean and have a variance of one.
 *
 * The number of rows occupied by X must be a multiple of 256. If fewer
 * observations than that exist, these rows may be made zero without affecting
 * calculations, and the n_obs parameter should reflect the number of valid
 * observations (i.e. should not include the zero-padding rows).
 *
 * Parameters:
 * @param d_Q       where to store the cumulant matrices
 * @param d_X       where to find the observation variables
 * @param q_ld      the leading dimension of the cumulant matrices
 * @param x_ld      the leading dimension of the observation matrix
 * @param n_obs     the number of observations in the X matrix
 * @param num_cm    the number of cumulant matrices to generate
 */
void __global__ jade_genCumulants( NUMTYPE *d_Q, NUMTYPE const *d_X,
                                   unsigned int q_ld, unsigned int x_ld,
                                   unsigned int n_obs, unsigned int num_cm );

/**
 * Name: jade_anglesStepOne
 *
 * Description:
 * Step one in the generation of a rotation matrix. To find the angle value
 * to minimize elements (p,q) and (q,p), we must first find:
 *    (1) ((p,p) - (q,q)) * ((p,p) - (q,q))
 *    (2) ((p,p) - (q,q)) * ((p,q) + (q,p))
 *    (3) ((p,q) + (q,p)) * ((p,q) + (q,p))
 * for every cumulant matrix. This kernel finds those three values for every
 * cumulant matrix, and every pair (p,q), where valid pairs are determined
 * based on the sequence number, `seq'.
 *
 * The cumulant matrices pointer should point to a set of cumulant matrices as
 * generated by the jade_genCumulants() kernel.
 *
 * The calculated values will be stored in the `d_vals' memory, where the first
 *   ((num_var/2) * num_cm)
 * values, where 
 *   num_cm = (num_var * (num_var + 1)) / 2
 * will be the set of (1) values referenced above, the next set of values will
 * be the (2) values, and the final set will be the (3) values.
 *
 * Values are grouped such that the first (num_var/2) values are for the first
 * cumulant matrix, the next set of (num_var/2) values are for the second
 * cumulant matrix, and so on.
 *
 * CUDA dimensions:
 * Given a set of cumulant matrices based on observations of `n' variables:
 * grid_size  = dim3( (n*(n+1)) / 2 )
 * block_size = dim3( n / 2 )
 *
 * Parameters:
 * @param d_vals        where to store the generated values
 * @param d_Q           where to find the cumulant matrices
 * @param q_ld          the leading dimension of the cumulant matrices
 * @param seq           the sequence number
 * @param num_var       how many variables are in the cumulant matrices
 */
void __global__ jade_anglesStepOne( NUMTYPE *d_vals, NUMTYPE const *d_Q,
                                    unsigned int q_ld,
                                    unsigned int seq, unsigned int num_var );

/**
 * Name: jade_anglesStepTwo
 *
 * Description:
 * Step two in the generation of a rotation matrix. To find the angle value
 * to minimize elements (p,q) and (q,p), we must now find the sum of the
 * values calculated in step one, and then perform a little more manipulation
 * to get the numbers we're looking for. That's what this kernel does.
 *
 * When complete, this kernel will have finished the generation of a rotation
 * matrix. The generated rotation matrix, `V', should be used as in the
 * following equation to minimize a set of off diagonal elements in the set
 * of cumulant matrices:
 *
 *   Q_next = V' * Q * V;
 *
 * Note the transpose operator. This kernel creates the rotation matrix so that
 * it is ready to be right-multipled with the cumulant matrices.
 *
 * The `d_vals' parameter should be as returned by the jade_anglesStepOne()
 * kernel.
 *
 * CUDA dimensions:
 * Given a set of values based on observations of `n' variables:
 * grid_size  = dim3( 1 )
 * block_size = dim3( 3 * (n / 2) )
 * @sh_mem     = sizeof(NUMTYPE) * 3 * (n/2)
 *
 * Parameters:
 * @param d_rot         where to store the generated rotation matrix
 * @param d_vals        where to find the values used to generate the matrix
 * @param rot_ld        the leading dimension of the rotation matrix
 * @param seq           the sequence number
 * @param num_var       how many variables are in the original observations
 */
void __global__ jade_anglesStepTwo( NUMTYPE *d_rot, NUMTYPE *d_vals,
                                    unsigned int rot_ld,
                                    unsigned int seq, unsigned int num_var );

/**
 * Name: jade_rightRot
 *
 * Description:
 * Right multiples the set of cumulant matrices by the given rotation matrix.
 *
 * The rotation will be performed inplace--the given set of cumulant matrices
 * will be modified.
 *
 * The sequence parameter should be the same value given to the jade_angles*
 * functions that generated the rotation matrix.
 *
 * CUDA dimensions:
 * grid_size  = dim3( (num_var - (num_var + 1) / 2 - 1) *
 *                     (num_var * (num_var + 1)) / 2, 0, 0 )
 * block_size = dim3( num_var * 2, 0, 0 )
 * sh_mem     = sizeof(NUMTYPE) * num_var * 2
 *
 * Parameters:
 * @param d_Q         where to find the cumulant matrices
 * @param d_rot       where to find the rotation matrix
 * @param rot_ld      the leading dimension of the rotation matrix
 * @param q_ld        the leading dimension of the cumulant matrix
 * @param sequence    the sequence number defining which elements to minimize
 * @param num_var     how many variables are in the cumulant matrices
 */
void __global__ jade_rightRot( NUMTYPE *d_Q, NUMTYPE *d_rot,
                               unsigned int rot_ld, unsigned int q_ld,
                               unsigned int sequence, unsigned int num_var );

/**
 * Name: jade_getPQ
 *
 * Description:
 * Given a sequence number, this function returns the (p,q) element indexs that
 * should be minimized by a given block.
 *
 * This computation is based the following paper:
 * Title = {On Jacobi and Jacobi-Like Algorithms for a Parallel Computer},
 * Author = {Sameh, Ahmed H.},
 * Copyright = {Copyright {\copyright} 1971 American Mathematical Society},
 * Journal = {Mathematics of Computation}
 *
 * `p' is guaranteed to be less than `q'.
 *
 * Parameters:
 * @param p           where to store the p (row) index
 * @param q           where to store the q (column) index
 * @param sequence    the sequence number used to determine p and q
 * @param pair        which (p,q) pair in the sequence to get
 * @param num_var     the number of rows in the matrix we're working on
 */
void __device__ jade_getPQ( unsigned int *p, unsigned int *q,
                            unsigned int sequence, unsigned int pair,
                            unsigned int num_var );

#endif
